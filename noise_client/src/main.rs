use noiseexplorer_kk::noisesession::{NoiseSession};
use noiseexplorer_kk::types::{Keypair};
use noiseexplorer_kk::consts::*;

use tokio::net::TcpStream;
use tokio::prelude::*;

use utils::{connect_tor_socks_proxy, print_msg, load_static_keypair, load_remote_pubkey, handle_hs_read, HS_MSG_LEN};

use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};
use tokio::prelude::*;

#[macro_use]
extern crate lazy_static;

lazy_static! {
    pub static ref TOR_PROXY_ADDR: SocketAddr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 9050));
}

// This was generated by running a local instance of Tor as a hidden service as per https://2019.www.torproject.org/docs/tor-onion-service.html.en
// Really this ONION_ADDR should be input during the ceremony through a GUI
const ONION_ADDR: &str = "exg3frizbx7te4fd26d4du5tmstc5wuen464phcbpnpsdtkvhrpx7ayd.onion";
const ONION_PORT: u16 = 80;


#[tokio::main]
async fn main() {
    // Connect to the server via the Tor network.
    let onion = format!("{}:{}", ONION_ADDR, ONION_PORT);
    let mut stream = connect_tor_socks_proxy(*TOR_PROXY_ADDR, onion.as_str()).await.expect("Failed to connect through Tor Proxy");
    println!("TorStream connection established");

    // Initialize noise session
    let s = load_static_keypair("client").unwrap();
    let rs = load_remote_pubkey("server").unwrap();
    let mut session = NoiseSession::init_session(true, &[0u8], s, Some(rs));

    // Handle Write
    let e_keypair = Keypair::default();

    let e = e_keypair.get_public_key().as_bytes();
    let mut in_out = [0u8; HS_MSG_LEN];
    in_out[..DHLEN].copy_from_slice(&e);

    session.set_ephemeral_keypair(e_keypair);
    session.send_message(&mut in_out).unwrap(); //processes in_out

    stream.write(&in_out).await.unwrap();
    print_msg(&in_out, true);

    // Handle Read
    let (reader, mut _writer) = stream.split();

    let mut msg_b = handle_hs_read(reader).await;
    print_msg(&msg_b, false);
    session.recv_message(&mut msg_b).unwrap();

    println!("message count = {:?}", session.get_message_count());
    println!("handshake hash = {:?}", session.get_handshake_hash());
    println!("is transport? {:?}", session.is_transport());

    // Following this, set up a loop where the client awaits user input for messages to be sent to the server.
}